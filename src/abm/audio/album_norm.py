"""Album-level loudness normalization helpers."""

from __future__ import annotations

import json
from pathlib import Path
from statistics import median

import numpy as np
import soundfile as sf

__all__ = [
    "collect_chapter_stats",
    "compute_album_offset",
    "apply_album_gain",
    "write_album_manifest",
]


def collect_chapter_stats(manifest_path: Path) -> list[dict]:
    """Collect QC stats for each chapter in ``manifest_path``.

    ``manifest_path`` should point to the ``book_manifest.json`` generated by
    :mod:`abm.audio.render_book`.  The returned list contains one dictionary per
    chapter with keys such as ``integrated_lufs`` and ``peak_dbfs``.
    """

    with manifest_path.open("r", encoding="utf-8") as f:
        manifest = json.load(f)
    out_dir = manifest_path.parent.parent
    stats: list[dict] = []
    for ch in manifest.get("chapters", []):
        qc_path = out_dir / ch["qc_path"]
        with qc_path.open("r", encoding="utf-8") as f:
            qc = json.load(f)
        merged = dict(ch)
        merged.update(qc)
        stats.append(merged)
    return stats


def compute_album_offset(stats: list[dict], target_lufs: float = -18.0) -> float:
    """Return the dB gain to apply so the median LUFS hits ``target_lufs``."""

    lufs_values = [s.get("integrated_lufs", target_lufs) for s in stats]
    if not lufs_values:
        return 0.0
    med = median(lufs_values)
    return float(target_lufs - med)


def apply_album_gain(wav_path: Path, out_path: Path, offset_db: float) -> None:
    """Apply a uniform gain to ``wav_path`` and write ``out_path``.

    The processing is performed in ``float32``.  If the scaled audio would clip,
    it is further scaled so the peak remains at most ``-1.2`` dBFS (a 0.2 dB
    margin below ``-1`` dBFS).
    """

    data, sr = sf.read(wav_path, dtype="float32")
    gain = 10 ** (offset_db / 20)
    data = data * gain
    peak = float(np.max(np.abs(data)))
    limit = 10 ** (-1.2 / 20)
    if peak > limit:
        data *= limit / peak
    out_path.parent.mkdir(parents=True, exist_ok=True)
    sf.write(out_path, data, sr, subtype="PCM_16")


def write_album_manifest(manifest_path: Path, offset_db: float) -> None:
    """Write a small JSON file describing the applied album gain."""

    manifest = {"album_gain_db": offset_db}
    manifest_path.parent.mkdir(parents=True, exist_ok=True)
    with manifest_path.open("w", encoding="utf-8") as f:
        json.dump(manifest, f, indent=2, sort_keys=True)
